# Idempotency Keys: Client-Generated

## Video Length: ~4-5 minutes | Level: Intermediate

---

## The Hook (20-30 seconds)

You're filling out a form. Click Submit. Network glitches. "Did it go through?" You have no idea. You click again. Without idempotency: two orders. Two charges. Double everything. With idempotency: each submission gets a unique ID—generated by *you*, the client. The server says: "I already processed that ID. Here's the same response." No duplicate. Safe to retry. That's the power of idempotency keys.

## The Story

Idempotency means: doing the same thing multiple times has the same effect as doing it once. GET is idempotent. Deleting the same resource twice is idempotent—first delete works, second returns 404, same end state. But POST to create an order? Not idempotent. Post twice, get two orders.

The fix: the **client** generates a unique key before sending. A UUID. Something like `idemp-abc-123-xyz`. Sends it in a header: `Idempotency-Key: idemp-abc-123-xyz`. The server stores that key. When it processes a request, it checks: "Have I seen this key before?" If yes: return the cached response. Don't process again. If no: process, store the result with the key, return.

## Another Way to See It

Think of a concert ticket. You buy it. You get a confirmation number. You're not sure if the payment went through. You click "Buy" again with the same card. The system sees your confirmation number. "Already processed. Here's your same ticket." You don't get charged twice. You don't get two tickets. The confirmation number is your idempotency key. Banks do this internally for ACH transfers. Duplicate detection windows. Same idea—identify the logical transaction, process once. You accidentally click "Buy" again. The system sees your confirmation number. "Already processed. Here's your same ticket." You don't get charged twice. The confirmation number is your idempotency key.

## Connecting to Software

Why **client-generated**? Because the client is the one retrying. Only the client knows: "This is the SAME request. I'm retrying because I didn't get a response." The server can't tell a retry from a new request. Same body, same endpoint. Without a key, they're identical. The key is the client saying: "This is my second attempt. Treat it as the same as the first."

Implementation: the server stores `(idempotency_key, status, response)` in a database or cache. The key is the primary lookup. Before processing any state-changing request, check: does this key exist? If yes and status is "completed," return the stored response. If yes and status is "in_progress," the original request might still be running—return 409 Conflict or wait. If no, process the request, store the result, return. The key must be unique per *logical* request. One order = one key. Retry of that same order = same key. New order = new key. Before processing: lookup the key. Exists? Return stored response. Doesn't exist? Process the request. Store the result. Return. Keys don't live forever. TTL of 24–48 hours. After that, the same key can be treated as new—usually for "create subscription" type operations. Why? Because a user might genuinely want to retry after a long delay. "I tried to subscribe yesterday, it failed, I'm trying again today." If you kept the key forever, you'd return the old response. That might be wrong (subscription expired, card changed). So keys expire. Document the TTL. Clients should generate new keys for genuinely new attempts.

## Let's Walk Through the Diagram

```
  CLIENT                          SERVER

  1. Generate key: idemp-xyz
  2. POST /orders
     Idempotency-Key: idemp-xyz
     Body: { items: [...] }

  3. Server: key idemp-xyz in DB? NO
  4. Process order → Order #1001
  5. Store: idemp-xyz → Order #1001
  6. Return 201, Order #1001

  --- Network fails. Client didn't get response. ---

  7. Client retries: POST /orders
     Idempotency-Key: idemp-xyz  (SAME KEY)
     Body: { items: [...] }

  8. Server: key idemp-xyz in DB? YES
  9. Return 201, Order #1001  (cached, no duplicate)
```

## Real-World Examples (2-3)

- **Stripe**: Idempotency keys on all POST requests. Create charge, create customer, create subscription. Same key = same result. Industry standard.
- **Payment gateways**: "Charge this card." Without idempotency, a retry could double-charge. With it, same key = same charge. Safe.
- **Order placement**: E-commerce. "Place order." User clicks twice. Same idempotency key. One order. The key comes from the client—often generated when the user lands on the checkout page. Attach it to the place-order request. Retries use the same key. Safe.

## Let's Think Together

**Client generates a key, sends a request. Server processes, stores the key. Server crashes before responding. Client retries with the same key. What happens?**

The server processed but didn't respond. So the key might not be stored—depends on when the crash happened. If the server stored the key in the same transaction as processing: key is there. Retry → return cached. If the server crashed before persisting: key not found. Retry → process again. Risk: duplicate! Best practice: store the key at the START of processing, before any side effects. Or use a DB transaction: process + store key atomically. If crash before commit, no key. Retry processes again. If process is truly idempotent (e.g., "create order if not exists"), that's OK. Otherwise, design carefully.

## What Could Go Wrong? (Mini Disaster Story)

You add idempotency. Great. But you expire keys after 24 hours. A user places an order. Doesn't get a response. Tries again the next day with the same key (maybe they saved it). Your server says "key expired, new request." Processes again. Two orders. Or: the client reuses keys for different requests. "We use idempotency key 'order-1' for all orders." Wrong. Each *logical* request needs a unique key. One order = one key. Next order = new key.

## Surprising Truth / Fun Fact

Stripe popularized idempotency keys in 2014. Before that, payment retries were a nightmare. "Did the charge go through? I'll try again." Double charge. "I won't retry." Lost payment. Now it's expected. AWS, Google Cloud, many APIs support it. The pattern is simple but critical: client-generated, server-deduplicated. A small header. A big safety net. If you're building any API that does state-changing operations—payments, orders, subscriptions—idempotency keys should be in your design from day one. Not an afterthought.

---

## Quick Recap (5 bullets)

- Idempotency key: unique ID from client, identifies "this is a retry of that request"
- Client-generated: only the client knows it's retrying; server can't tell otherwise
- Server stores key → response; on retry, returns cached response, no reprocessing
- Store key atomically with processing to handle crashes correctly
- Keys expire (24–48 hr); each logical request needs a unique key

## One-Liner to Remember

*Same key, same result. The client holds the key.*

---

## Next Video

Up next: Deduplication windows—how long do you need to remember "I've seen this before"? See you there.
